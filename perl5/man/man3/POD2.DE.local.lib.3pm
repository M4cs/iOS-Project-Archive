.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "POD2::DE::local::lib 3"
.TH POD2::DE::local::lib 3 "2014-01-20" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
local::lib~[de] \- Erschaffen und benutzen von Perl Modulen in einem lokalen lib/ Verzeichnis mit PERL5LIB
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Im Code \-
.PP
.Vb 1
\&  use local::lib; # Benutzt das Verzeichnis ~/perl5 zum anlegen des lokalen lib/ Verzeichnisses
\&
\&  use local::lib \*(Aq~/foo\*(Aq; # das selbe, aber mit ~/foo
\&
\&  # Oder...
\&  use FindBin;
\&  use local::lib "$FindBin::Bin/../support";  # Applikationsspezifische Sammlung von Modulen
.Ve
.PP
Von der Shell \-
.PP
.Vb 2
\&  # Installiert LWP und alle notwendigen Abhängigkeiten in das \*(Aq~/perl5\*(Aq Verzeichnis
\&  perl \-MCPAN \-Mlocal::lib \-e \*(AqCPAN::install(LWP)\*(Aq
\&
\&  # Gibt die Shell Kommandos aus um die Umgebung vorzubereiten
\&  $ perl \-Mlocal::lib
\&  export PERL_MB_OPT=\*(Aq\-\-install_base /home/username/perl5\*(Aq
\&  export PERL_MM_OPT=\*(AqINSTALL_BASE=/home/username/perl5\*(Aq
\&  export PERL5LIB=\*(Aq/home/username/perl5/lib/perl5/i386\-linux:/home/username/perl5/lib/perl5\*(Aq
\&  export PATH="/home/username/perl5/bin:$PATH"
.Ve
.SS "Die Bootstrapping Methode"
.IX Subsection "Die Bootstrapping Methode"
Ein typischer Weg um local::lib zu benutzen ist die sogenannte \*(L"Bootstrapping\*(R" Methode.
Diese Methode wird benutzt wenn noch kein local::lib auf dem System installiert ist.
In diesem Fall kannst du einfach local::lib direkt in deinem Home-Verzeichnis installieren.
.PP
Selbst wenn du administrative Rechte hast, ist es wichtig das die Umgebungsvariablen von
Schritt 4 in deinem Shell Startup Skript gesetzt werden. Ohne diesen Schritt werden die
Module von \s-1CPAN\s0 weiterhin im System installiert und auch Perl Skripte die du startest
würden das von local::lib erstellte lib/ Verzeichnis nicht nutzen.
.PP
Standardmäßig installiert sich local::lib in ~/perl5.
.PP
Windows Benutzern müssen ausserdem dies hier lesen:
\&\*(L"Unterschiede bei Benutzung dieses Module mit Win32\*(R".
.PP
1. Lade das Tar-Archiv von \s-1CPAN\s0 runter (Suche nach \*(L"Download\*(R" auf der \s-1CPAN\s0 Seite von
local::lib) und entpacke es in einem beliebigem Verzeichnis. Um das obige Problem zu
vermeiden, sollte man dies als normaler User tun und nicht als root oder Administrator.
.PP
2. Starte in dem entstandenen Verzeichnis folgenden Befehl:
.PP
.Vb 1
\&  perl Makefile.PL \-\-bootstrap
.Ve
.PP
Wenn das System dir vorschlägt gewisse Dinge eigenständig zu konfigurieren ist es in
fast allen Fällen vollkommen in Ordnung einfach \*(L"yes\*(R" zu antworten.
.PP
Falls du local::lib nicht in das Standard Verzeichnis installieren willst, musst du
dieses Verzeichnis als Parameter angeben:
.PP
.Vb 1
\&  perl Makefile.PL \-\-bootstrap=~/foo
.Ve
.PP
3. Danach folgenden Befehl starten: (local::lib erwartet make auf dem System)
.PP
.Vb 1
\&  make test && make install
.Ve
.PP
4. Nun müssen wir die benötigten Umgebungsvariablen, damit Perl unser neu generiertes
lib/ Verzeichnis benutzt. Wenn du bash oder eine andere Bourne Shell benutzt, kannst
du es über diesen Weg zu deinem Shell Startup Skript hinzufügen:
.PP
.Vb 1
\&  echo \*(Aqeval $(perl \-I$HOME/perl5/lib/perl5 \-Mlocal::lib)\*(Aq >>~/.bashrc
.Ve
.PP
Wenn du C Shell benutzt, du kannst das gleiche hiermit erreichen:
.PP
.Vb 4
\&  /bin/csh
\&  echo $SHELL
\&  /bin/csh
\&  perl \-I$HOME/perl5/lib/perl5 \-Mlocal::lib >> ~/.cshrc
.Ve
.PP
Wenn du beim bootstrappen ein anderes Verzeichnis benutzt als das Standardverzeichnis,
dann musst du dieses Verzeichnis als Parameter beim Laden des Modules local::lib angeben:
.PP
.Vb 1
\&  echo \*(Aqeval $(perl \-I$HOME/foo/lib/perl5 \-Mlocal::lib=$HOME/foo)\*(Aq >>~/.bashrc
.Ve
.PP
Nachdem diese Änderungen in deinem Shell Startup Skript gemacht wurden, ist es nun wichtig
das diese Umgebungsvariablen auch gesetzt sind in deiner aktuellen Umgebung. In Bourne
Shells macht man dies z.B. mit \f(CW\*(C`. ~/.bashrc\*(C'\fR, und in C Shell würde man es mit:
\&\f(CW\*(C`source ~/.cshrc\*(C'\fR mit.
.PP
Wenn du eine sehr langsames System hast, oder du unter drakonischen Regulierungen des
Plattenplatz leben musst, kann man die automatische Generierung der manpages vom \s-1POD\s0
bei der Installation des Moduls deaktivieren beim bootstrapping mit dem \f(CW\*(C`\-\-no\-manpages\*(C'\fR
Parameter:
.PP
.Vb 1
\&  perl Makefile.PL \-\-bootstrap \-\-no\-manpages
.Ve
.PP
Um zu vermeiden das man mehrere bootstraps macht um z.B. für verschiedene Applikationen
eigene local::lib Installationen zu nutzen, kann man eine dieser Umgebungen benutzen
um einfach in beliebigen anderen Verzeichnis Module zu installieren und somit weitere
eigenständige lib/ Umgebungen zu bekommen:
.PP
.Vb 4
\&  cd ~/mydir1
\&  perl \-Mlocal::lib=./
\&  eval $(perl \-Mlocal::lib=./)  ### Um die Umgebungsvariablen für die
\&                                ### aktuelle Shell zusetzen
\&
\&  printenv                      ### Hier kannst du sehen das ~/mydir1
\&                                ### in der PERL5LIB Umgebungsvariable
\&                                ### steht
\&
\&  perl \-MCPAN \-e install ...    ### welche Module auch immer ...
\&  cd ../mydir2
\&
\&  ... WIEDERHOLEN ...
.Ve
.PP
Für mehrere Umgebungen in dieser Form brauch man eine Modifikation in der
Benutzung von \f(CW\*(C`use FindBin\*(C'\fR in dem \*(L"Im Code\*(R" Beispiel oben.
Wenn du sowas machst, und du hast damit z.B. Perl Module nach \f(CW\*(C`~/mydir1/lib\*(C'\fR installiert und du hast ein Script in \f(CW\*(C`~/mydir1/scripts/myscript.pl\*(C'\fR, du musst dort angeben das die Module
die es braucht im Verzeichnis \f(CW\*(C`~/mydir1/lib\*(C'\fR liegen.
.PP
In \f(CW\*(C`~/mydir1/scripts/myscript.pl\*(C'\fR steht dann:
.PP
.Vb 5
\&  use strict;
\&  use warnings;
\&  use local::lib "$FindBin::Bin/..";  ### zeigt auf ~/mydir1 und local::lib
\&                                      ### findet dort lib
\&  use lib "$FindBin::Bin/../lib";     ### zeigt auf ~/mydir1/lib
.Ve
.PP
Setze das vor jeden \s-1BEGIN\s0 { ... } Block der die Module braucht die du
installiert hast.
.SS "Unterschiede bei Benutzung dieses Module mit Win32"
.IX Subsection "Unterschiede bei Benutzung dieses Module mit Win32"
Um die nötigen Umgebungsvariablen für diese Variablen in der derzeitigen
Sitzung mit \f(CW\*(C`CMD.EXE\*(C'\fR zu setzen, kann man folgendes kommando nutzen:
.PP
.Vb 5
\&  C:\e>perl \-Mlocal::lib
\&  set PERL_MB_OPT=\-\-install_base C:\eDOCUME~1\eADMINI~1\eperl5
\&  set PERL_MM_OPT=INSTALL_BASE=C:\eDOCUME~1\eADMINI~1\eperl5
\&  set PERL5LIB=C:\eDOCUME~1\eADMINI~1\eperl5\elib\eperl5;C:\eDOCUME~1\eADMINI~1\eperl5\elib\eperl5\eMSWin32\-x86\-multi\-thread
\&  set PATH=C:\eDOCUME~1\eADMINI~1\eperl5\ebin;%PATH%
\&
\&  ### Um die Umgebungsvariablen für diese Shell alleine zu setzen
\&  C:\e>perl \-Mlocal::lib > %TEMP%\etmp.bat && %TEMP%\etmp.bat && del %TEMP%\etemp.bat
\&  ### anstelle von $(perl \-Mlocal::lib=./) in bash.
.Ve
.PP
Wenn du willst das die Umgebungsvariablen dauerhaft gesetzt sind, musst du diese
in Systemsteuerung / System dauerhaft selber eintragen oder
App::local::lib::Win32Helper benutzen.
.PP
Die \*(L"~\*(R" wird übersetzt zu dem Benutzer Profil Verzeichnis (das Verzeichnis was
beim User als \*(L"Dokumente und Einstellungen\*(R" bekannt ist unter Windows \s-1XP\s0 und
vorher oder das \*(L"Benutzer\*(R" Verzeichnis bei Windows Vista und später), solange
\&\f(CW$ENV\fR{\s-1HOME\s0} nicht gesetzt ist. Das Verzeichnis wird hierbei zu dem korrekten
Kurznamen umgewandelt, und muss daher definitiv existieren, und wird um die
nötigen Unterverzeichnise erweitert.
.SH "GRUNDPRINZIP"
.IX Header "GRUNDPRINZIP"
Die Version von den Perl Paketen die man benötigt für spezifische Aufgaben sind
sehr häufig nicht die richtigen oder korrekten Versionen auf dem System
vorinstalliert. Ein Updaten von diesen Modulen ist in vielen Fällen einfach
nicht möglich weil die nötigen Rechte fehlen. Ausserdem ist es generell nicht
gut eigenständig die Versionen der Module auf dem System auszutauschen, weil
natürlich der Rest des Systems genau die Version erwartet die von der
Systemverwaltung auch installiert wurde.
.PP
local::lib löst dieses Problem, es erlaubt dir dein komplett eigenes Verzeichnis
für deine \s-1CPAN\s0 Module zu haben und bist so nicht genötigt die Module vom
System zu nutzen oder andersrum andere User nicht mit individuellen
Modulwünschen zu Überarbeitung ihres Codes zu zwingen, weil bestimmte Module
zentral für alle auf neuere Version upgedatet werden. Die Installation findet
hierbei dann z.B. im Home Verzeichnis statt. Es werden nur Umgebungsvariablen
gesetzt die das installierte Perl dazu bewegen die im Homeverzeichnis
installierten Module zu benutzen, zusätzlich und vorgezogen zu denen auf dem
System.
.PP
Daher muss man sich wenn man ein Paket System benutzt, wie z.b. Debian, garnicht
mehr Sorgen machen, irgendwas auf dem System zu verletzten nur durch die
Installation von Perl Modulen.
.SH "BESCHREIBUNG"
.IX Header "BESCHREIBUNG"
Dieses Modul bietet eine schnelle und legitime Art und Weise ein sogenanntes
bootstrapping zu machen um in einem User Homeverzeichnis eine Sammlung von
Modulen zu installieren. Es erstellt auch die nötigen Umgebungsvariablen
die benötigt werden um diese Module zu nutzen, passend zu der Shell die der
User in der Umgebungsvariable \f(CW\*(C`SHELL\*(C'\fR angegeben hat, um dann direkt passend
in die entsprechenden Konfigurationsdateien der Shell einfügt zu werden.
.PP
Weitergehend ist local::lib in der Lage Module zu nutzen die nicht im
standardmäßigen \f(CW@INC\fR Pfad von Perl enthalten sind. Das macht es einfacher
für bestimmte Applikationen ein bestimmtes Set von Modulen zu installieren
ohne die anderen Module auf dem System in irgendeiner Art anzufassen.
Damit es z.B. auch sicherer Module zu installieren die vom Maintainer noch
nicht als Release verfügbar sind.
.PP
Beim Import setzt local::lib die folgenden Umgebungsvariablen zu den
nötigen Werten:
.IP "\s-1PERL_MB_OPT\s0" 4
.IX Item "PERL_MB_OPT"
.PD 0
.IP "\s-1PERL_MM_OPT\s0" 4
.IX Item "PERL_MM_OPT"
.IP "\s-1PERL5LIB\s0" 4
.IX Item "PERL5LIB"
.IP "\s-1PATH\s0" 4
.IX Item "PATH"
.PD
Am \s-1PATH\s0 wird natürlich angehangen, und nicht ersetzt.
.PP
Diese Werte sind dann verfügbar für jeden Code der danach importiert wurde.
.SH "ERSTELLEN EINES EIGENSTÄNDIGE SAMMLUNG VON MODULEN"
.IX Header "ERSTELLEN EINES EIGENSTÄNDIGE SAMMLUNG VON MODULEN"
Mit lib::core::only besteht eine Möglichkeit dieses zutun, aber beachte das
hier eine Menge von Fallstricken und Problemen existieren, und man sollte
immer darauf achten das man auf einem Perl aufbaut was sowenig wie möglich
verändert wurde (d.h. site und vendor Verzeichnis so leer wie möglich).
.SH "METHODEN"
.IX Header "METHODEN"
.SS "ensure_dir_structure_for"
.IX Subsection "ensure_dir_structure_for"
.ie n .IP "Parameter: $path" 4
.el .IP "Parameter: \f(CW$path\fR" 4
.IX Item "Parameter: $path"
.PD 0
.IP "Rückgabewert: Keiner" 4
.IX Item "Rückgabewert: Keiner"
.PD
.PP
Versucht den angegebenen Pfad anzulegen, mit allen nötigen drüberliegenden
Verzeichnissen. Im Fehlerfall wird eine Exception geworfen.
.SS "print_environment_vars_for"
.IX Subsection "print_environment_vars_for"
.ie n .IP "Parameter: $pfad" 4
.el .IP "Parameter: \f(CW$pfad\fR" 4
.IX Item "Parameter: $pfad"
.PD 0
.IP "Rückgabewert: Keiner" 4
.IX Item "Rückgabewert: Keiner"
.PD
.PP
Gibt die Umgebungsvariablen aus, die benötigt werden um den angegebenen Pfad
als Basis Verzeichnis zu nutzen.
.SS "build_environment_vars_for"
.IX Subsection "build_environment_vars_for"
.ie n .IP "Parameter: $pfad, $interpolate" 4
.el .IP "Parameter: \f(CW$pfad\fR, \f(CW$interpolate\fR" 4
.IX Item "Parameter: $pfad, $interpolate"
.PD 0
.IP "Rückgabewert: \e%umgebungs_variablen" 4
.IX Item "Rückgabewert: %umgebungs_variablen"
.PD
.PP
Gibt ein Hash zurück mit den Variablen die nötig sind in den Umgebungsvariablen
um eine Installation in dem gegebenen Pfad zu benutzen.
.SS "setup_env_hash_for"
.IX Subsection "setup_env_hash_for"
.ie n .IP "Parameter: $pfad" 4
.el .IP "Parameter: \f(CW$pfad\fR" 4
.IX Item "Parameter: $pfad"
.PD 0
.IP "Rückgabewert: Keiner" 4
.IX Item "Rückgabewert: Keiner"
.PD
.PP
Setzt die \f(CW%ENV\fR Einträge basierend auf dem Aufruf von
\&\*(L"build_environment_vars_for\*(R".
.SS "install_base_perl_path"
.IX Subsection "install_base_perl_path"
.ie n .IP "Parameter: $pfad" 4
.el .IP "Parameter: \f(CW$pfad\fR" 4
.IX Item "Parameter: $pfad"
.PD 0
.ie n .IP "Rückgabewert: $module_installations_pfad" 4
.el .IP "Rückgabewert: \f(CW$module_installations_pfad\fR" 4
.IX Item "Rückgabewert: $module_installations_pfad"
.PD
.PP
Gibt den Pfad zurück der benutzt wird um Perl Module zu installieren bei
dem gegebenen Pfad als Basis. Prinzipiell wird nur \f(CW\*(C`lib\*(C'\fR und \f(CW\*(C`perl5\*(C'\fR als
Pfadelemente angehangen.
.SS "install_base_arch_path"
.IX Subsection "install_base_arch_path"
.ie n .IP "Parameter: $pfad" 4
.el .IP "Parameter: \f(CW$pfad\fR" 4
.IX Item "Parameter: $pfad"
.PD 0
.ie n .IP "Rückgabewert: $architektur_module_installations_pfad" 4
.el .IP "Rückgabewert: \f(CW$architektur_module_installations_pfad\fR" 4
.IX Item "Rückgabewert: $architektur_module_installations_pfad"
.PD
.PP
Gibt den Pfad zurück der benutzt wird um die Architektur\-abhängigen Perl
Module zu installieren basirend auf dem angegebenen Pfad als Basis. Basierend
auf dem was \*(L"install_base_perl_path\*(R" zurückgibt, and appends the value of
\&\f(CW$Config{archname}\fR.asis.
.SS "install_base_bin_path"
.IX Subsection "install_base_bin_path"
.ie n .IP "Parameter: $pfad" 4
.el .IP "Parameter: \f(CW$pfad\fR" 4
.IX Item "Parameter: $pfad"
.PD 0
.ie n .IP "Rückgabewert: $ausfuehrbare_programme_installations_pfad" 4
.el .IP "Rückgabewert: \f(CW$ausfuehrbare_programme_installations_pfad\fR" 4
.IX Item "Rückgabewert: $ausfuehrbare_programme_installations_pfad"
.PD
.PP
Gibt den Pfad zurück, wo ausführbare Programme installiert werden, basierend
auf der Basis des angegebenen Pfad. Basierend auf \*(L"install_base_perl_path\*(R"
Rückgabewert, hängt diese Methode noch \f(CW\*(C`bin\*(C'\fR an.
.SS "resolve_empty_path"
.IX Subsection "resolve_empty_path"
.ie n .IP "Parameter: $pfad" 4
.el .IP "Parameter: \f(CW$pfad\fR" 4
.IX Item "Parameter: $pfad"
.PD 0
.ie n .IP "Rückgabewert: $basis_pfad" 4
.el .IP "Rückgabewert: \f(CW$basis_pfad\fR" 4
.IX Item "Rückgabewert: $basis_pfad"
.PD
.PP
Erstellt und gibt zurück den Pfad der benutzt wird als Basis zur Installation
der Module. Standardmäßig dies ist \f(CW\*(C`~/perl5\*(C'\fR.
.ie n .SS "resolve_home_path( $path )"
.el .SS "resolve_home_path( \f(CW$path\fP )"
.IX Subsection "resolve_home_path( $path )"
.ie n .IP "Parameter: $pfad" 4
.el .IP "Parameter: \f(CW$pfad\fR" 4
.IX Item "Parameter: $pfad"
.PD 0
.ie n .IP "Rückgabewert: $home" 4
.el .IP "Rückgabewert: \f(CW$home\fR" 4
.IX Item "Rückgabewert: $home"
.PD
.PP
Versucht das Home Verzeichnis vom aktullen User zu finden. Wenn \f(CW\*(C`File::HomeDir\*(C'\fR
installiert ist, für dieses benutzt dafür. Es wird eine Exception geworfen, wenn
kein Home Verzeichnis ermittelt werden konnte.
.SS "resolve_relative_path"
.IX Subsection "resolve_relative_path"
.ie n .IP "Parameter: $pfad" 4
.el .IP "Parameter: \f(CW$pfad\fR" 4
.IX Item "Parameter: $pfad"
.PD 0
.ie n .IP "Rückgabewert: $absoluter_pfad" 4
.el .IP "Rückgabewert: \f(CW$absoluter_pfad\fR" 4
.IX Item "Rückgabewert: $absoluter_pfad"
.PD
.PP
Macht aus dem angegebenen Pfad einen absoluten Pfad.
.SS "resolve_path"
.IX Subsection "resolve_path"
.ie n .IP "Parameter: $pfad" 4
.el .IP "Parameter: \f(CW$pfad\fR" 4
.IX Item "Parameter: $pfad"
.PD 0
.ie n .IP "Rückgabewert: $absoluter_pfad" 4
.el .IP "Rückgabewert: \f(CW$absoluter_pfad\fR" 4
.IX Item "Rückgabewert: $absoluter_pfad"
.PD
.PP
Hierbei wird der Pfad durch die folgende Methoden gegeben, wobei der Rückgabewert
der ersten an die nächste weitergeben wird, um die Umgebung zu konfigurieren
für die lokale Bibliotheks Installation: \*(L"resolve_empty_path\*(R",
\&\*(L"resolve_home_path\*(R", \*(L"resolve_relative_path\*(R".
Der daraus resultierende Pfad wird zu \*(L"resolve_empty_path\*(R" übergeben, dessen
Resultat dann weitergegeben wird an \*(L"resolve_home_path\*(R", wessen Resultat dann
weitergegeben wird an \*(L"resolve_relative_path\*(R". Dieses Resultat wird dann final
an \*(L"resolve_path\*(R" übergeben, welches dann den Rückgabewert stellt.
.SH "EINE WARNUNG VOR UNINST=1"
.IX Header "EINE WARNUNG VOR UNINST=1"
Wenn man local::lib in Kombination mit \*(L"make install UNINST=1\*(R" benutzt, muss
man vorsichtig sein über die Tatsache das der Prozess über die Neuinstallation
eine nicht ausreichende Sicherheit hat bezüglich wo er nun installieren muss.
Hierdurch mann es passieren das beim deinstallieren eines Modul u.U. das
globale Modul deinstalliert wird (wenn die Rechte vorhanden sind) aber die
neue Version nur in der lokalen Version installiert ist. Es ist hier also sehr
wichtig das man \*(L"make install UNINST=1\*(R" und local::lib nur gleichzeitig
benutzt wenn man sehr sicher darüber ist welche Konsequenzen einem
entgegenkommen.
.SH "EINSCHRÄNKUNGEN"
.IX Header "EINSCHRÄNKUNGEN"
Die Werkzeuge von perl, die benutzt werden um die Pakete zu installieren
(die sogenannte toolchain), sind leider nicht in der Lage sauber mit
Verzeichnissen umzugehen die Leerzeichen enthalten und können daher local::lib
nicht direkt in ein solches Verzeichnis installieren. Was du machen kannst
ist \fBnach\fR der Installation von local::lib und der Module die du in deiner
local::lib haben willst, das gesamte Verzeichnis dahin zu bewegen. local::lib
kann mit dem Verzeichnis mit Leerzeichen umgehen. Bitte aufpassen das natürlich
eine weitere Installation oder ein Erneuern von Paketen mit dem \s-1CPAN\s0 Programm
nicht mehr möglich ist.
.PP
Die Shell Erkennung ist sehr primitiv. Derzeit ist es so das alles was \*(L"csh\*(R"
im Namen hat auch als C Shell eingeordnet wird, und alles andere wird als
Bourne Shell betrachet, ausser auf Win32 Systemen. Wenn die \f(CW\*(C`SHELL\*(C'\fR Variable
nicht gesetzt ist, eine Bourne Shell wird angenommen.
.PP
Bootstrap ist leider ein Hack, und wird auf jedenfall \s-1CPAN\s0.pm benutzen für
ExtUtils::MakeMaker, auch wenn \s-1CPANPLUS\s0 installiert ist.
.PP
Es setzt definitiv \s-1PERL5LIB, PERL_MM_OPT\s0 und \s-1PERL_MB_OPT\s0 neu und vernichtet
jeden Wert der vorher gesetzt war.
.PP
Es sollte vielleicht eine automatische Korrektur der \s-1CPAN\s0 Config machen, wenn
das nicht schon gemacht wurde.
.PP
\&\*(L"Patches Welcome\*(R" \- Patches sind immer willkommen beim Autor oder den anderen
Mitwirkenden.
.PP
Auf Win32 Systemen werden die Umgebungsvariablen nicht direkt in die Registrierung
geschrieben damit sie auch nach dem Neustarten erhalten bleiben.
.SH "FEHLERANALYSE"
.IX Header "FEHLERANALYSE"
Wenn du local::lib konfiguriert hast \s-1CPAN\s0 Module in deinem Home Verzeichnis
zu installieren, und du danach versuchst mit \f(CW\*(C`cpan \-i Foo::Bar\*(C'\fR ein Modul
zu installieren, und dabei einen Fehler bekommst, wie: \f(CW\*(C`Warning: You do not
have permissions to install into /usr/lib64/perl5/site_perl/5.8.8/x86_64\-linux at
/usr/lib64/perl5/5.8.8/Foo/Bar.pm\*(C'\fR und in der installationsausgabe steht
irgendwo ein Fehler der sagt \f(CW\*(C`\*(AqINSTALL_BASE\*(Aq is not a known MakeMaker parameter
name\*(C'\fR, dann hast du aus irgendeinem Grund dein neue Version von ExtUtils::MakeMaker
verloren.
.PP
Um dies zu korrigieren, einfach nochmal die bootstrapping Methode laufen lassen,
wie oben beschrieben.
.PP
Dann starte \f(CW\*(C`rm \-r ~/.cpan/build/Foo\-Bar*\*(C'\fR
.PP
Abschliessend dann nochmal mit \f(CW\*(C`cpan \-i Foo::Bar\*(C'\fR installieren und die Probleme
sollten verschwunden sein.
.SH "UMGEBUNGSVARIABLEN"
.IX Header "UMGEBUNGSVARIABLEN"
.IP "\s-1SHELL\s0" 4
.IX Item "SHELL"
.PD 0
.IP "\s-1COMSPEC\s0" 4
.IX Item "COMSPEC"
.PD
local::lib schaut in die \f(CW\*(C`SHELL\*(C'\fR Umgebungsvariable um die korrekten Kommandos
zu der Shell Konfiguration hinzuzufügen.
.Sp
Auf Win32 Systemen, \f(CW\*(C`COMSPEC\*(C'\fR wird auch analysiert.
.SH "SUPPORT"
.IX Header "SUPPORT"
\&\s-1IRC:\s0
.PP
.Vb 1
\&    Wir sind im Channel #local\-lib auf dem Server irc.perl.org.
.Ve
.SH "AUTOR DER ÜBERSETZUNG"
.IX Header "AUTOR DER ÜBERSETZUNG"
Torsten Raudssus <torsten@raudssus.de> http://www.raudssus.de/
.SH "URHEBERRECHT"
.IX Header "URHEBERRECHT"
Copyright (c) 2007 \- 2010 von den local::lib \*(L"\s-1AUTHOR\*(R"\s0 in local::lib
und \*(L"\s-1CONTRIBUTORS\*(R"\s0 in local::lib aufgelistet in local::lib.
.SH "LIZENZ"
.IX Header "LIZENZ"
Diese Sammlung ist freie Software und kann unter der selben Lizenz verbreitet
werden wie Perl selber.
